# cSpell: disable
# ====== Alphabet and Common Symbol ======
# Greek / Hebrew Letters
# Delimiters
# Math Constructs
# Variable - sized Symbols
# Standard Functions
# Operators and Relations
# Arrows
# Accents
# Miscellaneous
# Letter Styles
global
const heading_level = {
    "#": "chapter",
    "##": "section", 
    "###": "subsection", 
    "####": "subsubsection", 
    "#####": "paragraph", 
    "######": "subparagraph"
};

function gen_fraction(line) {
    const stripped = line.slice(0, -1);
    let depth = 0;
    let i = stripped.length - 1;

    // Find the outermost opening parenthesis
    while (i >= 0) {
        if (stripped[i] === ')') depth += 1;
        if (stripped[i] === '(') depth -= 1;
        if (depth === 0) break;
        i -= 1;
    }
    return stripped.slice(0, i) + "\\frac{" + stripped.slice(i + 1, -1) + "}";
}

function list(context) {
    return context.scopes.some(s => s === "meta.function.environment.list.latex");
}

function math(context) {
    return context.scopes.some(s => s === "support.class.math.block.environment.latex");
}
    
endglobal

# ===== Mathmatical Constants =====
context math(context)
snippet dd "dd" iA
\mathrm{d}
endsnippet

context math(context)
snippet ee "ee" iA
\e
endsnippet

context math(context)
snippet `(ii|jj)` "ii" iA
\ii
endsnippet

# ====== Greek and Hebrew Letters ======
context math(context)
priority 100
snippet `(?<!\\)(mu|rho|pi|beta|zeta|eta|iota|nu|pi|rho|tau|phi|Phi|xi|chi|psi|Xi|Pi|Phi|Psi)` "greek" iA
\\``rv = m[1]``
endsnippet

priority 100
context math(context)
snippet eps "epsilon" iA
\epsilon
endsnippet

context math(context)
snippet lam "lambda" iA
\lambda
endsnippet

context math(context)
snippet tht "theta" iA
\theta
endsnippet

context math(context)
snippet del "delta" iA
\delta
endsnippet

context math(context)
snippet Del "Delta" iA
\Delta
endsnippet

context math(context)
snippet alp "alpha" iA
\alpha
endsnippet

context math(context)
snippet sig "sigma" iA
\sigma
endsnippet

context math(context)
snippet `(?<!\\)gam` "gamma" iA
\gamma
endsnippet

context math(context)
snippet `(?<!\\)Gam` "Gamma" iA
\Gamma
endsnippet

priority 200
context math(context)
snippet veps "varepsilon" iA
\varepsilon
endsnippet
# ====== Delimiters ======
priority 100
context math(context)
snippet (). "left( right)" iA
\left( ${0} \right)
endsnippet

priority 100
context math(context)
snippet ||. "left| right|" iA
\left| ${0} \right|
endsnippet

priority 100
context math(context)
snippet []. "left[ right]" iA
\left[ ${0} \right]
endsnippet

priority 100
context math(context)
snippet {}. "left\{ right\}" iA
\left\\{ ${0} \right\\}
endsnippet

priority 100
context math(context)
snippet <>. "left< right>" iA
\langle ${0} \rangle
endsnippet

context math(context)
snippet /. "substitute" iA
\left. ${1} \right|_{$0}
endsnippet

context math(context)
snippet set "set" iA
\left\\{ ${1} \mid $0 \right\\}
endsnippet

context math(context)
snippet binom "binomial" iA
\binom{${1:n}}{${2:k}}$0
endsnippet

# ====== Math Constructs ======

context math(context)
snippet // "auto fraction Visual" iA
\\frac{${1:${VISUAL}}}{$2}$0
endsnippet

# Modified from https://castel.dev/post/lecture-notes-1/#fractions
context math(context)
snippet `((\d+)|(\d*)((\\)?(([A-Za-z]+)((\^|_)(\{\d+\}|\d))*))+)/` "auto fraction with multiplication" iA
\\frac{``rv = m[1]``}{$1}$0
endsnippet

priority 300
context math(context)
snippet `^.*\)/` "() Fraction" iA
``rv = gen_fraction(m[0])``{$1}$0
endsnippet

context math(context)
snippet pw "power" iA
^{${1:n}} 
endsnippet

context math(context)
snippet sr "square" iA
^{2}$0
endsnippet

context math(context)
snippet cb "cube" iA
^{3}$0
endsnippet

context math(context)
snippet `(?<!\\)inv`"inverse" iA
^{-1}$0
endsnippet

context math(context)
snippet adj "adjoint" iA
^{*}
endsnippet

context math(context)
snippet sb "subscript" iA
_{${1:2}}$0
endsnippet

context math(context)
snippet `([A-Za-z])(\d)` "auto subscript for single digit" iA
`` rv = m[1] + "_" + m[2]``
endsnippet

context math(context)
snippet `([A-Za-z])_(\d) ` "auto bracklet for single digit subscript" iA
`` rv = m[1] + "_{" + m[2] + "}"``
endsnippet

priority 100
context math(context)
snippet `([A-Za-z])_(\d\d)` "auto subscript for double digit" iA
`` rv = m[1] + "_{" + m[2] + "}"`` 
endsnippet

context math(context)
snippet `(?<!\\)([A-Za-z}])\.([0-9a-z])` "auto subscript for letters with dot" iA
`` rv = m[1] + "_{" + m[2] + "}" ``
endsnippet


# There is a heated discussion about the typesetting of \d 
# https://tex.stackexchange.com/questions/14821/whats-the-proper-way-to-typeset-a-differential-operator/637613
# ISO Standard: https://tug.org/tugboat/tb18-1/tb54becc.pdf
# I am currently using derivative package
# But you shouldn't worry about it as long as you are consistent throughout the document

priority 200
context math(context)
snippet `(?<!\\)dintt` "definite integral" iA
\int_{${1:0}}^{${2:\infty}} ${4:${VISUAL}} \\d{${5:x}}$0
endsnippet

priority 200
context math(context)
snippet `(?<!\\)intq` "line integral" iA
\int_{${1:L}} ${2:${VISUAL}} \\d{${3:s}}$0
endsnippet

priority 100
context math(context)
snippet `(?<!\\)intt` "integral" iA
\int ${1} \\d{${2:x}} ${4:${VISUAL}}
endsnippet

priority 200
context math(context)
snippet `(?<!\\)iintt` "integrate" iA
\iint_{${1:D}} ${4:${VISUAL}} $0
endsnippet

priority 300
context math(context)
snippet `(?<!\\)iiintt` "integrate" iA
\iiint_{${1:V}} ${4:${VISUAL}} $0
endsnippet

context math(context)
snippet `(?<!\\)sumt` "sumt" iA
\sum_{${1:n}=${2:1}}^{${3:\infty}} ${4:${VISUAL}}
endsnippet

context math(context)
snippet `(?<!\\)sumq` "sumq" iA
\sum_{$1} ${0:${VISUAL}}
endsnippet

context math(context)
snippet `\\capt` "bigcap" iA
\bigcap_{${1:i}=1}^{${2:\infty}} ${4:${VISUAL}}
endsnippet

context math(context)
snippet `\\capq` "bigcap" iA
\bigcap_{$1} ${0:${VISUAL}}
endsnippet

context math(context)
snippet `\\cupt` "bigcup" iA
\bigcup_{${1:i}=1}^{${2:\infty}} ${4:${VISUAL}}
endsnippet

context math(context)
snippet `\\cupq` "bigcap" iA
\bigcup_{$1} ${0:${VISUAL}}
endsnippet

context math(context)
snippet `\\sqcupt` "bigsqcup" iA
\bigsqcup_{${1:i}=1}^{${2:\infty}} ${4:${VISUAL}}
endsnippet

context math(context)
snippet `\\sqcapq` "bigsqcap" iA
\bigsqcap_{$1} ${0:${VISUAL}}
endsnippet

context math(context)
snippet `\\sqcupq` "bigsqcup" iA
\bigsqcup_{$1} ${0:${VISUAL}}
endsnippet


context math(context)
snippet `\\infq` "infinmum" iA
\inf_{$1} ${0:${VISUAL}}
endsnippet

context math(context)
snippet `\\supq` "supremum" iA
\sup_{$1} ${0:${VISUAL}}
endsnippet

context math(context)
snippet `(?<!\\)lim` "limit" iA
\lim_{${1:n} \to ${2:\infty}} ${4:${VISUAL}}
endsnippet

context math(context)
snippet `(?<!\\)prod` "product" iA
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}}
endsnippet


context math(context)
snippet `OVER` "over" iA
\overbrace{${1:${VISUAL}}}
endsnippet

context math(context)
snippet `UNDER` "under" iA
\underbrace{${1:${VISUAL}}}
endsnippet

# ====== Structure of the Document ======
# End tabbing as soon as possible to allow room for GitHub Copilot
snippet `(#{1,5})\s` "Headings" iA
\``rv = heading_level[m[1]]``{${0:${VISUAL}}}
endsnippet

snippet `\u0060\u0060\u0060|···` "environment" iA
\begin{${1:align*}}
${0:${VISUAL}}
\end{${1:align*}}
endsnippet

context list(context)
snippet `^(\s*)\+\s` "enumerate list item gen" iA
``rv = m[1]``\item ${0}
endsnippet

snippet `^(\s*)\+\s` "enumerate list gen" iA
\begin{enumerate}
    \item ${0}
\end{enumerate}
endsnippet

context list(context)
snippet `^(\s*)\d\s` "itemize list item gen" iA
``rv = m[1]``\item ${0}
endsnippet

snippet `^1\.\s` "itemize list gen" iA
\begin{itemize}
    \item ${0}
\end{itemize}
endsnippet

context list(context)
snippet `^(\s*)\-\s` "description list item gen" iA
``rv = m[1]``\item[${1:label}] ${0}
endsnippet 

snippet `^\s*\-\s` "description list gen" iA
\begin{description}
    \item[${1:label}] ${0}
\end{description}
endsnippet

snippet `^\s*prob` "Problem" iA
\begin{problem}{$1}
${0:${VISUAL}}
\end{problem}
endsnippet

snippet `^\s*def` "Definition" iA
\begin{definition}{$1}
${0:${VISUAL}}
\end{definition}
endsnippet

snippet `^\s*thm` "Theorem" iA
\begin{theorem}{$1}
${0:${VISUAL}}
\end{theorem}
endsnippet

snippet `^\s*claim` "Lemma" iA
\begin{claim}{$1}
${0:${VISUAL}}
\end{claim}
endsnippet

snippet `^\s*note` "Note" iA
\begin{note}{$1}
${0:${VISUAL}}
\end{note}
endsnippet

snippet `^\s*proof` "Proof" iA
\begin{proof}
${0:${VISUAL}}
\end{proof}
endsnippet

snippet ==== "Highlight" iA
\hl{${1:${VISUAL}}}
endsnippet

snippet `^todo` "TODO" iA
% TODO: $0
endsnippet

# This is to avoid conflict with Italic snippet
# You can also customize the snippet something like `^^`
priority 200
snippet \textit{** "Bold" iA
\textbf{${1:${VISUAL}}
endsnippet

priority 100
snippet ** "Italic" iA
\textit{${1:${VISUAL}}}$0
endsnippet

snippet ~~~~ "Underline" iA
\underline{${1:${VISUAL}}}$0
endsnippet

===== Standard Functions =====

context math(context)
snippet `(?<!\\)(sin|cos|tan|cot|sec|csc|arcsin|arccos|arctan)` "trig function" iA
\\``rv = m[1]``
endsnippet

context math(context)
snippet `(?<!\\)(exp|ln|inf|sup)` "analytic function" iA
\\``rv = m[1]``
endsnippet

context math(context)
snippet `(?<!\\)(det|dim)` "linear algebra function" iA
\\``rv = m[1]``
endsnippet

context math(context)
snippet `(?<!\\)(cap|cup|sqcup|sqcap)` "set theory function" iA
\\``rv = m[1]``$0
endsnippet

context math(context)
snippet sqrt "\sqrt{}" iA
\sqrt{${1}}$0
endsnippet

===== Operators and Relations =====
priority 100
context math(context)
snippet inn iA
\in $0
endsnippet

priority 200
context math(context)
snippet !inn "not in" iA
\notin $0
endsnippet

context math(context)
snippet != "no equals" iA
\neq 
endsnippet

priority 200
context math(context)
snippet <= "less than or equal to" iA
\leq $0
endsnippet

priority 200
context math(context)
snippet >= "greater than or equal to" iA
\geq $0
endsnippet

context math(context)
snippet `(?<!\\)sub` "subset" iA
\subset$0
endsnippet

context math(context)
snippet `\\subset=` "subset or equal" iA
\subseteq $0
endsnippet

context math(context)
snippet == "equivalent" iA
\equiv $0
endsnippet

context math(context)
snippet >> "greater than" iA
\gg $0
endsnippet

context math(context)
snippet << "less than" iA
\ll $0
endsnippet

context math(context)
snippet ~~ "sim" iA
\sim $0
endsnippet

context math(context)
snippet \\\ "backslash" iA
\backslash $0
endsnippet

priority 100
context math(context)
snippet ~= "Isomorphism" iA
\cong $0
endsnippet

priority 200
context math(context)
snippet !~= "not isomorphism" iA
\not\cong $0
endsnippet

context math(context)
snippet +- "plus minus" iA
\pm $0
endsnippet

context math(context)
snippet -+ "minus plus" iA
\mp $0
endsnippet

# Require package mathtools
context math(context)
snippet := "define" iA
\coloneqq $0
endsnippet

context math(context)
snippet |-> "mapsto" iA
\mapsto $0
endsnippet

# I use \newcommand{\abs}[1]{\left|#1\right|}
context math(context)
snippet abs "absolute value" iA
\abs{$0}
endsnippet

priority 100
context math(context)
snippet xx "times" iA
\times $0
endsnippet


priority 200
context math(context)
snippet oxx "otimes" iA
\otimes $0
endsnippet

priority 200
context math(context)
snippet lxx "left semidirect product" iA
\ltimes $0
endsnippet

priority 200
context math(context)
snippet rxx "right semidirect product" iA
\rtimes $0
endsnippet

===== Arrows =====

context math(context)
snippet -> "to" iA
\to $0
endsnippet

context math(context)
snippet <- "left arrow" iA
\leftarrow $0
endsnippet

context math(context)
snippet => "implies" iA
\implies $0
endsnippet

context math(context)
snippet =< "implied by" iA
\impliedby $0
endsnippet

context math(context)
snippet iff "if and only if" iA
\iff $0
endsnippet

context math(context)
snippet `(\\?[a-zA-Z]\w*({?\w*})?)(hvec)` "Vector postfix" iA
\vec{ ``rv = m[1]`` }
endsnippet

===== Miscellaneous =====
context math(context)
snippet fa iA
\forall $0
endsnippet

# avoid conflict with snippet "\exp" and "\times"
# avoid conflict with \xi
priority 200
context math(context)
snippet exi iA
\exists $0
endsnippet

context math(context)
snippet ... "ellipsis" iA
\dots $0
endsnippet

context math(context)
snippet c... "cdots" iA
\cdots $0
endsnippet

context math(context)
snippet ** "cdot" iA
\cdot $0
endsnippet

priority 100
context math(context)
snippet oo "infinity" iA
\infty $0
endsnippet
===== Letter Styles =====

context math(context)
snippet RR "real number" iA
\R
endsnippet

context math(context)
snippet ZZ "integer" iA
\Z
endsnippet

context math(context)
snippet NN "natural number" iA
\N
endsnippet

context math(context)
snippet QQ "rational number" iA
\Q
endsnippet

context math(context)
snippet CC "complex number" iA
\C
endsnippet

context math(context)
snippet TT "transpose" iA
^{\mathrm{T}}
endsnippet

context math(context)
snippet `([A-Za-z])mscr` "Auto caligraphic" iA
\mathscr{``rv = m[1]``}
endsnippet

context math(context)
snippet mscr "caligraphic" iA
\mathscr{${0:${VISUAL}}}
endsnippet

context math(context)
snippet `([A-Za-z])mbb` "Auto blackboard bold" iA
\mathbb{``rv = m[1]``}
endsnippet

context math(context)
snippet mbb "blackboard bold" iA
\mathbb{${0:${VISUAL}}}
endsnippet

context math(context)
snippet `(\\)?([A-Za-z]+)mbf` "Auto boldface" iA
\bm{``rv = m[2]``}
endsnippet

# Require package bm
# https://tex.stackexchange.com/questions/595/how-can-i-get-bold-math-symbols
context math(context)
snippet mbf "boldface" iA
\bm{${0:${VISUAL}}}
endsnippet

context math(context)
snippet `([A-Za-z])mcal` "Auto caligraphic" iA
\mathcal{``rv = m[1]``}
endsnippet

context math(context)
snippet mcal "caligraphic" iA
\mathcal{${0:${VISUAL}}}
endsnippet