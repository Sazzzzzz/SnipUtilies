# cSpell: disable
# ====== Alphabet and Common Symbol ======
# Greek / Hebrew Letters
# Delimiters
# Math Constructs
# Variable - sized Symbols
# Standard Functions
# Operators and Relations
# Arrows
# Accents
# Miscellaneous
# Letter Styles
global
const heading_level = {
    "#": "chapter",
    "##": "section", 
    "###": "subsection", 
    "####": "subsubsection", 
    "#####": "paragraph", 
    "######": "subparagraph"
};

function gen_fraction(line) {
    const stripped = line.slice(0, -1);
    let depth = 0;
    let i = stripped.length - 1;

    // Find the outermost opening parenthesis
    while (i >= 0) {
        if (stripped[i] === ')') depth += 1;
        if (stripped[i] === '(') depth -= 1;
        if (depth === 0) break;
        i -= 1;
    }
    return stripped.slice(0, i) + "\\frac{" + stripped.slice(i + 1, -1) + "}";
}

endglobal

# ===== Mathmatical Constants =====

snippet dd "dd" iAm
\mathrm{d}
endsnippet

snippet ee "ee" iAm
\e
endsnippet

snippet `(ii|jj)` "ii" iAm
\ii
endsnippet

# ====== Greek and Hebrew Letters ======
priority 100
snippet `(?<!\\)(mu|rho|pi|beta|zeta|eta|iota|nu|pi|rho|tau|phi|Phi|xi|chi|psi|Xi|Pi|Phi|Psi)` "greek" iAm
\\``rv = m[1]``
endsnippet

priority 100
snippet eps "epsilon" iAm
\epsilon
endsnippet

snippet lam "lambda" iAm
\lambda
endsnippet

snippet tht "theta" iAm
\theta
endsnippet

snippet del "delta" iAm
\delta
endsnippet

snippet alp "alpha" iAm
\alpha
endsnippet

snippet sig "sigma" iAm
\sigma
endsnippet

priority 200
snippet veps "varepsilon" iAm
\varepsilon
endsnippet
# ====== Delimiters ======
priority 100
snippet (). "left( right)" Aim
\left( ${0} \right)
endsnippet

priority 100
snippet ||. "left| right|" Aim
\left| ${0} \right|
endsnippet

priority 100
snippet []. "left[ right]" Aim
\left[ ${0} \right]
endsnippet

priority 100
snippet {}. "left\{ right\}" Aim
\left\\{ ${0} \right\\}
endsnippet

priority 100
snippet <>. "left< right>" Aim
\langle ${0} \rangle
endsnippet

snippet /. "substitute" iAm
\left. ${1} \right|_{$0}
endsnippet

snippet set "set" iAm
\left\\{ ${1} \mid $0 \right\\}
endsnippet

snippet binom "binomial" iAm
\binom{${1:n}}{${2:k}}$0
endsnippet

# ====== Math Constructs ======

snippet // "auto fraction Visual" iAm
\\frac{${1:${VISUAL}}}{$2}$0
endsnippet

# Modified from https://castel.dev/post/lecture-notes-1/#fractions
snippet `((\d+)|(\d*)((\\)?(([A-Za-z]+)((\^|_)(\{\d+\}|\d))*))+)/` "auto fraction with multiplication" iAm
\\frac{``rv = m[1]``}{$1}$0
endsnippet

priority 300
snippet `^.*\)/` "() Fraction" iAm
``rv = gen_fraction(m[0])``{$1}$0
endsnippet

snippet pw "power" iAm
^{${1:n}} 
endsnippet

snippet sr "square" iAm
^{2}$0
endsnippet

snippet cb "cube" iAm
^{3}$0
endsnippet

snippet `(?<!\\)inv`"inverse" iAm
^{-1}$0
endsnippet

snippet adj "adjoint" iAm
^{*}
endsnippet

snippet sb "subscript" iAm
_{${1:2}}$0
endsnippet

snippet `([A-Za-z])(\d)` "auto subscript for single digit" iAm
`` rv = m[1] + "_" + m[2]``
endsnippet

snippet `([A-Za-z])_(\d) ` "auto bracklet for single digit subscript" iAm
`` rv = m[1] + "_{" + m[2] + "} " ``
endsnippet

priority 100
snippet `([A-Za-z])_(\d\d)` "auto subscript for double digit" iAm
`` rv = m[1] + "_{" + m[2] + "}"`` 
endsnippet

snippet `(?<!\\)([A-Za-z}])\.([0-9a-z])` "auto subscript for letters with dot" iAm
`` rv = m[1] + "_{" + m[2] + "}" ``
endsnippet


# There is a heated discussion about the typesetting of \d 
# https://tex.stackexchange.com/questions/14821/whats-the-proper-way-to-typeset-a-differential-operator/637613
# ISO Standard: https://tug.org/tugboat/tb18-1/tb54becc.pdf
# I am currently using `\renewcommand{\d}[1]{\operatorname{d}\!{#1}}`
# But you shouldn't worry about it as long as you are consistent throughout the document

priority 200
snippet `(?<!\\)dintt` "definite integral" iAm
\int_{${1:a}}^{${2:b}} ${4:${VISUAL}} \\d{5:x}$0
endsnippet

priority 200
snippet `(?<!\\)intq` "line integral" iAm
\int_{${1:L}} ${2:${VISUAL}} \\d{3:s}$0
endsnippet

priority 100
snippet `(?<!\\)intt` "integral" iAm 
\int ${1} \\d{2:x} ${4:${VISUAL}}
endsnippet

priority 200
snippet `(?<!\\)iintt` "integrate" iAm
\iint_{${1:D}} ${4:${VISUAL}} $0
endsnippet

priority 300
snippet `(?<!\\)iiintt` "integrate" iAm
\iiint_{${1:V}} ${4:${VISUAL}} $0
endsnippet

snippet `(?<!\\)sumt` "sumt" iAm
\sum_{${1:n}=${2:1}}^{${3:\infty}} ${4:${VISUAL}}
endsnippet

snippet `(?<!\\)sumq` "sumq" iAm
\sum_{$1} ${0:${VISUAL}}
endsnippet

snippet `\\capt` "bigcap" iAm
\bigcap_{${1:i}=1}^{${2:\infty}} ${4:${VISUAL}}
endsnippet

snippet `\\capq` "bigcap" iAm
\bigcap_{$1} ${0:${VISUAL}}
endsnippet

snippet `\\cupt` "bigcup" iAm
\bigcup_{${1:i}=1}^{${2:\infty}} ${4:${VISUAL}}
endsnippet

snippet `\\cupq` "bigcap" iAm
\bigcup_{$1} ${0:${VISUAL}}
endsnippet

snippet `\\sqcupt` "bigsqcup" iAm
\bigsqcup_{${1:i}=1}^{${2:\infty}} ${4:${VISUAL}}
endsnippet

snippet `\\sqcapq` "bigsqcap" iAm
\bigsqcap_{$1} ${0:${VISUAL}}
endsnippet

snippet `\\sqcupq` "bigsqcup" iAm
\bigsqcup_{$1} ${0:${VISUAL}}
endsnippet


snippet `\\infq` "infinmum" iAm
\inf_{$1} ${0:${VISUAL}}
endsnippet

snippet `\\supq` "supremum" iAm
\sup_{$1} ${0:${VISUAL}}
endsnippet

snippet `(?<!\\)lim` "limit" iAm
\lim_{${1:n} \to ${2:\infty}} ${4:${VISUAL}}
endsnippet

snippet `(?<!\\)prod` "product" iAm
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}}
endsnippet


# ====== Structure of the Document ======
# End tabbing as soon as possible to allow room for GitHub Copilot
snippet `(#{1,5})\s` "Headings" iA
\``rv = heading_level[m[1]]``{${0:${VISUAL}}}
endsnippet

snippet `\u0060\u0060\u0060|···` "environment" iA
\begin{${1:align*}}
${0:${VISUAL}}
\end{${1:align*}}
endsnippet

snippet `^\+\s` "enumerate list" iA
\begin{enumerate}
	\item ${0}
\end{enumerate}
endsnippet

snippet `^1\.\s` "itemize list" iA
\begin{itemize}
	\item ${0}
\end{itemize}
endsnippet

snippet `^\-\s` "description list" iA
\begin{description}
    \item[${1:label}] ${0}
\end{description}
endsnippet

snippet pob "Problem" iA
\begin{problem}
${1:${VISUAL}}
\end{problem}
endsnippet

snippet sol "Solution" iA
\begin{solution}
${1:${VISUAL}}
\end{solution}
endsnippet

# For reasons that `soul` package is not compatible with Chinese documents
# I use the following command to highlight
# \newcommand\hl{\bgroup\markoverwith
# {\textcolor{yellow}{\rule[-.5ex]{2pt}{2.5ex}}}\ULon}
snippet ==== "Highlight" iA
\hl{${1:${VISUAL}}}
endsnippet

snippet `^todo` "TODO" iA
% TODO: $0
endsnippet

# This is to avoid conflict with Italic snippet
# You can also customize the snippet something like `^^`
priority 200
snippet \textit{** "Bold" iA
\textbf{${1:${VISUAL}}
endsnippet

priority 100
snippet ** "Italic" iA
\textit{${1:${VISUAL}}}$0
endsnippet

snippet ~~~~ "Underline" iA
\underline{${1:${VISUAL}}}$0
endsnippet

===== Standard Functions =====

snippet `(?<!\\)(sin|cos|tan|cot|sec|csc|arcsin|arccos|arctan)` "trig function" iAm
\\``rv = m[1]``
endsnippet

snippet `(?<!\\)(exp|ln|inf|sup)` "analytic function" iAm
\\``rv = m[1]``
endsnippet

snippet `(?<!\\)(det|dim)` "linear algebra function" iAm
\\``rv = m[1]``
endsnippet

snippet `(?<!\\)(cap|cup|sqcup|sqcap)` "set theory function" iAm
\\``rv = m[1]``$0
endsnippet

snippet sqrt "\sqrt{}" iAm
\sqrt{${1}}$0
endsnippet

===== Operators and Relations =====
priority 100
snippet inn iAm
\in $0
endsnippet

priority 200
snippet !inn "not in" iAm
\notin $0
endsnippet

snippet != "no equals" iAm
\neq 
endsnippet

priority 200
snippet <= "less than or equal to" iAm
\leq $0
endsnippet

priority 200
snippet >= "greater than or equal to" iAm
\geq $0
endsnippet

snippet `(?<!\\)sub` "subset" iAm
\subset$0
endsnippet

snippet `\\subset=` "subset or equal" iAm
\subseteq $0
endsnippet

snippet == "equivalent" iAm
\equiv $0
endsnippet

snippet >> "greater than" iAm
\gg $0
endsnippet

snippet << "less than" iAm
\ll $0
endsnippet

snippet ~~ "sim" iAm
\sim $0
endsnippet

snippet \\\ "backslash" iAm
\backslash $0
endsnippet

priority 100
snippet ~= "Isomorphism" iAm
\cong $0
endsnippet

priority 200
snippet !~= "not isomorphism" iAm
\not\cong $0
endsnippet

snippet +- "plus minus" iAm
\pm $0
endsnippet

snippet -+ "minus plus" iAm
\mp $0
endsnippet

# Require package mathtools
snippet := "define" iAm
\coloneqq $0
endsnippet

snippet |-> "mapsto" iAm
\mapsto $0
endsnippet

# I use \newcommand{\abs}[1]{\left|#1\right|}
snippet abs "absolute value" iAm
\abs{$0}
endsnippet

priority 100
snippet xx "times" iAm
\times $0
endsnippet

priority 100
snippet oo "circled times" iAm
\circ $0
endsnippet

priority 200
snippet oxx "otimes" iAm
\otimes $0
endsnippet

priority 200
snippet lxx "left semidirect product" iAm
\ltimes $0
endsnippet

priority 200
snippet rxx "right semidirect product" iAm
\rtimes $0
endsnippet

===== Arrows =====

snippet -> "to" iAm
\to $0
endsnippet

snippet <- "left arrow" iAm
\leftarrow $0
endsnippet

snippet => "implies" iAm
\implies $0
endsnippet

snippet =< "implied by" iAm
\impliedby $0
endsnippet

snippet iff "if and only if" iAm
\iff $0
endsnippet

snippet `(\\?[a-zA-Z]\w*({?\w*})?)(hvec)` "Vector postfix" iAm
\vec{ ``rv = m[1]`` }
endsnippet

===== Miscellaneous =====
snippet fa iAm
\forall $0
endsnippet

# avoid conflict with snippet "\exp" and "\times"
# avoid conflict with \xi
priority 200
snippet exi iAm
\exists $0
endsnippet

snippet ... "ellipsis" iAm
\dots $0
endsnippet

snippet ** "cdot" iAm
\cdot $0
endsnippet


===== Letter Styles =====

snippet RR "real number" iAm
\R
endsnippet

snippet ZZ "integer" iAm
\Z
endsnippet

snippet NN "natural number" iAm
\N
endsnippet
	
snippet QQ "rational number" iAm
\Q
endsnippet

snippet CC "complex number" iAm
\C
endsnippet

snippet TT "transpose" iAm
^{\mathrm{T}}
endsnippet

snippet `([A-Za-z])mscr` "Auto caligraphic" iAm
\mathscr{``rv = m[1]``}
endsnippet

snippet mscr "caligraphic" iAm
\mathscr{${0:${VISUAL}}}
endsnippet

snippet `([A-Za-z])mbb` "Auto blackboard bold" iAm
\mathbb{``rv = m[1]``}
endsnippet

snippet mbb "blackboard bold" iAm
\mathbb{${0:${VISUAL}}}
endsnippet

snippet `(\\)?([A-Za-z]+)mbf` "Auto boldface" iAm
\bm{``rv = m[2]``}
endsnippet

# Require package bm
# https://tex.stackexchange.com/questions/595/how-can-i-get-bold-math-symbols
snippet mbf "boldface" iAm
\bm{${0:${VISUAL}}}
endsnippet

snippet `([A-Za-z])mcal` "Auto caligraphic" iAm
\mathcal{``rv = m[1]``}
endsnippet

snippet mcal "caligraphic" iAm
\mathcal{${0:${VISUAL}}}
endsnippet
